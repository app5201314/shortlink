1.我看你这个项目是一个开源项目？
对，这是一个开源技术社区的项目，是我和几个朋友在业余时间一起开发的。

2.短链接是以什么方式生成的？
短链接我们尽可能希望生成最短的，所以我们采用了谷歌的MurMurHash算法生成32位hash值，然后再进行base62编码，形成6位的短链接后缀。

3.你们的短链接有没有设置有效期？

4.短链接的长度是可变的吗？大概能生成多少短链接呢？
长度不可变，短链接的组成是我们的域名搭配6位生成的后缀，62 的6次方，大概可以生成近57亿个短链接。

5.我看你这里主要是做的项目优化吧？主要是做了哪些优化呢？
视频7min的位置
优化这一块的话，主要是针对特定模块，比如短链接生成，短链接

6.短链接的缓存键值对是怎么设计的？数据库里面也是有一份的吧？

7.如果创建的时候，生成了相同的短链接？你的意思是不同的短链接生成相同的短链接吗？

8.你这里的消息队列主要是用来做什么？

9.消息队列这里有什么特别的配置吗？比如持久化？
15：25min
消息存储：RocketMQ将所有的消息存储在CommitLog文件中，这是一个存储所有消息数据的大文件。当新的消息到达时，RocketMQ会将消息追加到CommitLog文件的末尾。

刷盘策略：RocketMQ支持同步刷盘和异步刷盘两种策略。同步刷盘是指每次写入消息后，立即将数据从内存刷到磁盘；异步刷盘是指先将消息写入内存，然后通过后台线程定期将内存中的数据刷到磁盘。  

高可用性：RocketMQ通过主从复制（Master-Slave Replication）机制来保证消息的高可用性。在主从复制中，主节点会将消息复制到从节点，如果主节点出现故障，可以立即切换到从节点，以保证消息的可用性。

10.消息队列这块，如果服务挂了，还有没有消费完的服务，怎么办？你有做持久化方面的配置吗？

11.你这块有什么监控的组件吗？例如，监控系统状态，请求？
答：Sentinel。如果请求数过高，我们就会进行熔断降级处理

12.那这个过高你们是怎么界定的？

13，你这个（熔断降级策略）是针对单个ip还是用户？

14.你这块有访问日志吗？

15.点评项目秒杀那一块是怎么设计的？

16.你们这个短链宝项目有实际部署到服务器上用吗？

17.你们是怎么找到这个项目的瓶颈的？比如cpu占用过高啊？内存占用高啊？或者是响应慢？
前端f12
jemeter

18.后端排查问题的日志有做吗？

19.短链宝这个项目有用到多线程的技术吗？

20.预编译sql有用到吗？

21.有哪些场景是不能用预编译的？
动态SQL语句：如果你的SQL语句需要根据程序运行时的条件动态生成，那么预编译可能就不适用了。
因为预编译的SQL语句在编译时就已经确定了，无法在运行时动态改变。

22.java8里面，你有用到它的什么特性吗？
25:15
在Java 8中，我使用了以下几种特性：  
Lambda表达式：Lambda表达式是Java 8的一个重要特性，它可以使代码更简洁，更易读。我在处理集合、线程等场景时使用了Lambda表达式。  
Stream API：Stream API是Java 8中处理集合的一个强大工具，它可以非常方便地进行复杂的数据处理操作。  
Optional类：Optional类是Java 8引入的一个用于防止NullPointerException异常的工具类，我在处理可能出现空值的情况时使用了Optional类。  
新的日期和时间API：Java 8引入了全新的日期和时间API，这些API更加易用，更加强大。  
接口的默认方法和静态方法：Java 8允许在接口中定义默认方法和静态方法，这使得接口的功能更加强大。  
以上就是我在Java 8中使用的主要特性。

23.lambda表达式你觉得有什么缺点吗？
可读性问题：对于不熟悉Lambda表达式的开发者来说，Lambda表达式可能会降低代码的可读性。特别是当Lambda表达式变得复杂时，理解它的逻辑可能会变得困难。

调试困难：在使用Lambda表达式时，由于Lambda表达式是匿名函数，所以在调试过程中可能会遇到一些困难。例如，你不能为Lambda表达式设置断点。

作用域问题：Lambda表达式可以访问其外部作用域的变量，但这些变量必须是final或者是effectively final的。这意味着你不能在Lambda表达式中修改外部作用域的变量。

在本项目中使用了大量的lambda表达式，比如在记录短链接访客信息时，我们需要判断一下该用户是否是首次访问，如果用户是首次访问，我们将uvFlag设置为true，否则设置为false。
这里我们使用了Stream流，通过filter方法过滤出符合条件的数据，然后使用 findAny 方法判断是否存在符合条件的数据，最后使用ifPresentOrElse方法来处理不同的逻辑。
![img.png](imgx.png)

异常处理：Lambda表达式不能抛出受检异常，只能抛出运行时异常。这可能会限制Lambda表达式的使用场景。

24.有遇到过依赖冲突吗？

25.一般怎么看依赖有没有冲突？或者说预防这个问题？
27：00
依赖冲突的预防：
明确版本号：在添加依赖时，尽量明确指定依赖的版本号，避免使用范围或者最新版本，这样可以减少因版本更新导致的冲突。

使用依赖管理工具：使用如Maven的dependencyManagement元素

避免不必要的依赖：尽量减少不必要的依赖，每添加一个新的依赖都可能带来新的冲突。

26.依赖冲突一般是什么情况导致的？
版本冲突：项目中的不同部分依赖于同一库的不同版本，这可能导致版本冲突。例如，模块A依赖于库X的1.0版本，而模块B依赖于库X的2.0版本。  
传递依赖冲突：项目的直接依赖可能没有冲突，但是它们的传递依赖可能存在冲突。例如，模块A依赖于库X和库Y，库X的1.0版本依赖于库Z的1.0版本，而库Y的1.0版本依赖于库Z的2.0版本。  
依赖链冲突：在复杂的项目中，可能存在长的依赖链，这些依赖链可能导致冲突。例如，模块A依赖于库X，库X依赖于库Y，库Y依赖于库Z，而模块A也直接依赖于库Z。如果库Y需要库Z的1.0版本，而模块A需要库Z的2.0版本，那么就会产生冲突。

27.你有没有用到哪些工具来分析它们版本是不一致的？

28.有用过git吗？

29，linux你有用过吗？

30.有没有用过systemctl？
systemctl 是 Linux 系统中 systemd 的主命令，用于控制 systemd 系统和服务管理器。systemd 是一个系统初始化方案，用于 Linux 发行版以替代 init 系统。  systemctl 命令可以管理系统中的各种实体，这些实体在 systemd 中被称为“单元”（units）。单元可以是服务（service），挂载点（mount point），设备（device）等等。  以下是一些常用的 systemctl 命令：  
systemctl start [服务名]：启动一个服务。
systemctl stop [服务名]：停止一个服务。
systemctl restart [服务名]：重启一个服务。
systemctl reload [服务名]：当服务支持的情况下，重新加载服务配置。
systemctl status [服务名]：查看服务的状态。
systemctl enable [服务名]：使服务在启动时自动运行。
systemctl disable [服务名]：禁止服务在启动时自动运行。
systemctl list-units：列出当前加载的所有单元。
systemctl list-unit-files：列出所有单元文件及其状态（启用、禁用或静态）。
这些命令提供了一种统一的、结构化的方式来控制和管理 Linux 系统中的各种服务和进程。

31.为什么我们会用到这个命令？而不是直接写脚本？有什么好处？
简洁性：systemctl命令提供了一种简洁的方式来管理服务。例如，你可以使用systemctl start [服务名]来启动一个服务，而不需要编写复杂的脚本。  
统一性：systemctl命令提供了一种统一的方式来管理所有的服务和进程。无论你是想要启动、停止、重启服务，还是想要查看服务的状态，都可以通过systemctl命令来完成。
使用systemctl命令确实比直接编写脚本来管理服务更安全。以下是一些原因：  
权限管理：systemctl命令需要管理员权限才能执行，这可以防止未授权的用户随意启动或停止服务。  
服务隔离：使用systemd和systemctl可以为每个服务创建一个独立的环境，这可以防止服务之间相互影响，提高系统的稳定性和安全性。  
错误处理：systemctl命令可以处理服务启动失败的情况，例如，如果服务启动失败，systemctl可以自动重启服务，或者通知管理员。  
日志管理：systemd和systemctl提供了强大的日志管理功能，可以帮助管理员更好地监控服务的运行状态，及时发现和处理问题。

32.docker这块你有用过吗？

33.docker挂载或者说docker持久化有几种方式？
Docker 提供了几种不同的数据持久化和存储方式：  
卷（Volumes）：卷是 Docker 推荐的持久化数据的方式。卷是在 Docker 主机的文件系统中的特定目录，独立于容器生命周期的存在，可以被一个或多个容器挂载使用。卷的使用可以通过 docker volume create 命令创建，然后在 docker run 命令中通过 -v 或 --mount 参数挂载到容器中。  
绑定挂载（Bind Mounts）：绑定挂载可以将 Docker 主机上的任意目录或文件挂载到容器中。与卷不同，绑定挂载可以访问 Docker 主机上的任意位置，包括系统文件和目录。绑定挂载的使用可以在 docker run 命令中通过 -v 或 --mount 参数指定。  
tmpfs 挂载（tmpfs mounts）：tmpfs 挂载将一个在内存中的临时文件系统挂载到容器中。这种方式的数据不会持久化，当容器停止时，数据会丢失。tmpfs 挂载的使用可以在 docker run 命令中通过 --tmpfs 参数指定。

绑定挂载（Bind Mounts）是 Docker 中的一种数据持久化和存储方式，它可以将 Docker 主机上的任意目录或文件挂载到容器中。与卷（Volumes）不同，绑定挂载可以访问 Docker 主机上的任意位置，包括系统文件和目录。

以下是一个使用绑定挂载的例子：

```bash
docker run -d -p 8080:80 -v /path/on/host:/path/in/container nginx:latest
```

在这个例子中，`-v /path/on/host:/path/in/container` 就是使用了绑定挂载。`/path/on/host` 是 Docker 主机上的目录，`/path/in/container` 是容器内的目录。这个命令会启动一个新的 nginx 容器，并将主机上的 `/path/on/host` 目录挂载到容器的 `/path/in/container` 目录。

这样，容器内的应用就可以直接访问和操作主机上的 `/path/on/host` 目录，实现数据的持久化存储。同时，主机上对 `/path/on/host` 目录的修改也会立即反映到容器内，实现数据的实时同步。

需要注意的是，使用绑定挂载时，需要确保 Docker 主机上的目录已经存在，否则 Docker 会默认创建一个空目录。

数据卷（Volumes）是 Docker 中的一种数据持久化和存储方式。数据卷是在 Docker 主机的文件系统中的特定目录，独立于容器生命周期的存在，可以被一个或多个容器挂载使用。

以下是一个使用数据卷的例子：

```bash
docker volume create myvol
docker run -d -p 8080:80 -v myvol:/path/in/container nginx:latest
```

在这个例子中，首先使用 `docker volume create myvol` 命令创建了一个名为 `myvol` 的数据卷。然后在 `docker run` 命令中，通过 `-v myvol:/path/in/container` 参数将这个数据卷挂载到容器的 `/path/in/container` 目录。

这样，容器内的应用就可以直接访问和操作数据卷 `myvol` 中的数据，实现数据的持久化存储。同时，数据卷中的数据也可以被其他容器共享和使用。

需要注意的是，数据卷的生命周期独立于容器，即使容器被删除，数据卷中的数据也不会丢失，可以被其他容器继续使用。这是数据卷相比于其他挂载方式（如绑定挂载）的一个重要优点。

绑定挂载（Bind Mounts）和数据卷（Volumes）都是 Docker 提供的数据持久化和存储方式，但它们之间存在一些关键的区别：  
位置：绑定挂载可以将 Docker 主机上的任意目录或文件挂载到容器中，这意味着你可以访问 Docker 主机上的任意位置，包括系统文件和目录。而数据卷是在 Docker 主机的文件系统中的特定目录，这个目录是由 Docker 管理的。  
生命周期：数据卷的生命周期独立于容器，即使容器被删除，数据卷中的数据也不会丢失，可以被其他容器继续使用。而绑定挂载的生命周期则取决于 Docker 主机上的目录或文件。  
共享和复制：数据卷可以在多个容器之间共享和复制，而绑定挂载则取决于 Docker 主机上的目录或文件是否可以被多个容器访问。  
备份和迁移：数据卷更适合进行备份和迁移，因为 Docker 提供了对数据卷的原生支持，可以使用 Docker CLI 或 API 来备份、恢复或迁移数据卷。而对于绑定挂载，你需要自己处理备份和迁移的问题。  
性能：在某些情况下，数据卷的性能可能会优于绑定挂载，因为数据卷是由 Docker 直接管理的，而绑定挂载则需要通过 Docker 主机的文件系统。

34.假如说，系统要存文件？你会怎么存？用数据库还是？（指用户上传的文件）
用户上传的文件通常可以存储在以下几种地方：  
文件系统：这是最直接的方式，将文件保存在服务器的文件系统中。这种方式简单直接，但需要处理文件的路径和名称，防止文件名冲突等问题。同时，如果服务器有多个，还需要处理文件同步的问题。  

数据库：可以将文件（通常是小文件）保存在数据库中，如MySQL的BLOB字段。这种方式可以方便地管理文件，但会增加数据库的负担，可能影响数据库的性能。  

对象存储服务：如Amazon S3，阿里云OSS等，这些是专门用来存储文件的云服务，可以提供大量的存储空间，且有很好的稳定性和可用性。这种方式适合存储大文件和大量的文件。  

分布式文件系统：如Hadoop的HDFS，FastDFS等，这些系统可以将文件分布在多个节点上，既可以提供大量的存储空间，又可以提高文件读写的性能。  

BLOB 是 Binary Large OBject 的缩写，它是 MySQL 数据库中用于存储二进制数据的一种数据类型。BLOB 字段可以存储大量的二进制数据，如图片、音频、视频等。  MySQL 提供了四种 BLOB 类型，分别是 TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。这四种类型的主要区别在于它们能存储的数据的最大长度不同：  
TINYBLOB：最大 255 字节
BLOB：最大 65,535 字节
MEDIUMBLOB：最大 16,777,215 字节
LONGBLOB：最大 4,294,967,295 字节
在使用 BLOB 字段时，需要注意的是，虽然 BLOB 字段可以存储大量的数据，但是它会增加数据库的负担，可能影响数据库的性能。
因此，如果需要存储的数据非常大，或者数据量非常大，可能需要考虑其他的存储方式，如文件系统或对象存储服务等。

是的，HTTP可以设置压缩。这通常通过在HTTP响应中使用`Content-Encoding`头来实现。最常见的压缩方案是gzip和deflate。

当服务器返回一个使用gzip或deflate压缩的响应时，它会在`Content-Encoding`头中包含这个信息。浏览器或其他客户端在接收到这样的响应时，会自动解压缩数据，然后再处理。

例如，一个使用gzip压缩的HTTP响应的头部可能会包含以下信息：

```
Content-Encoding: gzip
```

要启用HTTP压缩，你需要配置你的服务器或者应用框架。例如，在Nginx中，你可以在配置文件中添加`gzip on;`来启用gzip压缩。

HTTP压缩可以显著减少传输的数据量，从而提高网页加载速度，减少带宽使用，提高用户体验。但是，它也会增加服务器的CPU使用率，因为服务器需要对数据进行压缩处理。因此，是否启用HTTP压缩，需要根据具体情况来决定。

35.如果不用那些呢？要你自己存怎么存？

36.HTTP可以设置压缩吗？
在许多Web服务器和应用服务器中，都可以设置HTTP压缩。这里以Nginx服务器为例，展示如何设置HTTP压缩。

首先，你需要在Nginx的配置文件中启用gzip模块。这通常在`nginx.conf`文件中，或者在`/etc/nginx/sites-available/default`（在某些Linux发行版中）文件中。以下是一个简单的配置示例：

```nginx
http {
    gzip on;
    gzip_disable "msie6";
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
}
```

这个配置启用了gzip压缩，并设置了一些参数：

- `gzip on;` 启用gzip压缩。
- `gzip_disable "msie6";` 不对IE6进行压缩（因为IE6不支持gzip压缩）。
- `gzip_vary on;` 在响应头中添加"Vary: Accept-Encoding"，让代理服务器知道不同的客户端是否接受压缩。
- `gzip_proxied any;` 对所有经过代理的请求进行压缩。
- `gzip_comp_level 6;` 压缩级别，1是最低级别（压缩比最低，CPU使用最少），9是最高级别（压缩比最高，CPU使用最多），6是一个折中的选择。
- `gzip_buffers 16 8k;` 设置压缩缓冲区大小，这里是16个8KB。
- `gzip_http_version 1.1;` 设置支持压缩的HTTP协议版本。
- `gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;` 设置需要压缩的MIME类型。

保存并退出配置文件后，需要重启Nginx服务以使新的配置生效：

```bash
sudo systemctl restart nginx
```

这样，Nginx服务器就会对指定类型的HTTP响应进行gzip压缩了。

37.用过nginx吗？

38.用过slf4j吗？
SLF4J（Simple Logging Facade for Java）和 Log4J 是 Java 世界中常用的两种日志框架。

SLF4J 是一个为各种日志框架提供统一接口的库，它本身并不进行日志记录。SLF4J 允许用户在部署时选择所需的日志框架，例如 Log4J、java.util.logging、Logback 等。这种设计使得用户可以在不修改源代码的情况下，更换日志框架。

Log4J 是 Apache 的一个开源项目，是一个功能强大的日志框架。它提供了多种日志记录级别，可以将日志信息输出到多个目标，如控制台、文件、GUI 组件等。Log4J 还支持通过配置文件动态地修改日志行为，无需修改应用程序代码。

SLF4J 和 Log4J 的主要区别在于，SLF4J 是一个日志接口，而 Log4J 是一个日志实现。SLF4J 允许你在运行时切换到任何你选择的日志实现，而 Log4J 则是其中一种可选的日志实现。

SLF4J 和 Log4J 的联系在于，SLF4J 提供了一个名为 slf4j-log4j12 的适配器，可以将 SLF4J 的日志接口转发到 Log4J，使得使用 SLF4J 接口的应用程序可以利用 Log4J 进行日志记录。

39.为什么用它？有什么优点？

40.为什么不用log4j？

41.我直接New一个线程，然后让它start运行，这样有什么问题吗？
直接创建并启动线程在某些情况下是可以的，但在大规模或复杂的多线程应用中，这种方式可能会带来一些问题：

1. **资源消耗**：每个线程都会消耗系统资源，包括内存、CPU时间等。如果创建大量的线程，可能会导致系统资源耗尽。

2. **性能问题**：线程的创建和销毁都需要时间和计算资源。如果频繁地创建和销毁线程，可能会导致性能问题。

3. **稳定性问题**：如果线程数量过多，可能会导致系统的稳定性下降。例如，过多的线程可能会导致操作系统达到线程数量的上限，导致新的线程无法创建。

4. **线程控制**：直接创建的线程，其生命周期和状态控制较为复杂。例如，你可能需要手动处理线程同步、线程间通信等问题。

因此，对于大规模或复杂的多线程应用，通常推荐使用线程池来管理和控制线程。线程池可以有效地复用线程，减少线程创建和销毁的开销，提高系统的稳定性和性能。同时，线程池还提供了更加方便的API来控制线程的状态和任务调度。

42.OOM一般是什么原因导致的？
堆内存溢出：Java的堆内存用于存储对象实例。如果你的应用创建了大量的对象，并且长时间无法被垃圾回收，那么堆内存可能会耗尽，导致OOM错误。  
永久代（PermGen）或元空间（Metaspace）溢出：这些区域用于存储Java类的元数据。如果你的应用加载了大量的类，那么这些区域可能会耗尽，导致OOM错误。需要注意的是，PermGen在Java 8中被Metaspace取代。
创建过多线程：每个线程都有一个栈，用于存储局部变量和方法调用。如果创建了过多的线程，可能会耗尽内存，导致OOM错误。

43.怎么避免OOM呢？
合理设置堆内存大小：你可以通过JVM的-Xms和-Xmx参数来设置堆内存的最小值和最大值。如果你的应用需要处理大量的数据，可能需要增大堆内存的大小。  
优化代码，减少内存使用：尽量减少不必要的对象创建，及时释放不再使用的对象，使用内存更加高效的数据结构等。
使用WeakReference、SoftReference、PhantomReference：Java提供了弱引用、软引用和虚引用，这些引用类型所指向的对象都可以被垃圾回收器回收。在适当的场景下使用这些引用，可以有效地减少内存使用。  
使用分页查询：如果需要从数据库查询大量的数据，可以使用分页查询，避免一次性加载过多的数据到内存中。
使用流式处理：对于处理大文件或大量的数据，可以使用流式处理。流式处理只需要加载一部分数据到内存中，可以显著减少内存使用。  
监控和调优JVM：使用JVM提供的工具（如JConsole，VisualVM等）来监控内存使用情况，及时发现和解决内存问题。你也可以使用JVM的各种参数来调优内存使用，例如调整垃圾回收器的行为等。

44.如果我一定要加载一个很大的文件呢？
流式处理是一种处理大数据或大文件的技术，它的主要思想是只将需要处理的数据部分加载到内存中，而不是一次性将所有数据加载到内存中。这种方式可以显著减少内存使用，避免出现内存溢出的问题。

在Java中，可以使用各种流类（如InputStream、OutputStream、Reader、Writer等）来实现流式处理。这些流类提供了按字节或字符读写数据的方法，可以逐个或逐块地处理数据，而不需要一次性加载所有数据。

例如，如果你需要读取一个大文件，可以使用BufferedReader来逐行读取文件，而不是一次性将文件的所有内容加载到内存中。以下是一个简单的例子：

```java
try (BufferedReader reader = new BufferedReader(new FileReader("largefile.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        // 处理每一行数据
        processLine(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

在这个例子中，`BufferedReader.readLine()`方法每次只读取文件的一行数据，因此无论文件有多大，都只需要很少的内存就可以处理。

同样的，如果你需要写入一个大文件，可以使用BufferedWriter来逐行写入文件，以下是一个简单的例子：

```java
try (BufferedWriter writer = new BufferedWriter(new FileWriter("largefile.txt"))) {
    for (String line : lines) {
        // 写入每一行数据
        writer.write(line);
        writer.newLine();
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

在这个例子中，`BufferedWriter.write()`方法每次只写入一行数据，因此无论需要写入多少数据，都只需要很少的内存就可以处理。

总的来说，流式处理是一种有效的处理大数据或大文件的方法，它可以显著减少内存使用，提高程序的性能和稳定性。