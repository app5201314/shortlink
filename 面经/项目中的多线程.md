# 进程与线程
![img_209.png](img_209.png)

![img_210.png](img_210.png)

# 并行与并发
![img_211.png](img_211.png)

![img_212.png](img_212.png)

![img_213.png](img_213.png)

# 线程
创建线程的方法：
![img_214.png](img_214.png)

![img_215.png](img_215.png)

![img_216.png](img_216.png)

![img_217.png](img_217.png)

![img_218.png](img_218.png)

![img_219.png](img_219.png)

![img_220.png](img_220.png)

问：重写run方法为啥不能抛异常，答：请参考方法重写的规则，并且看看父类的run方法声明

不能抛异常是因为：简化线程的异常处理 避免线程阻塞 提高代码的健壮性 保持接口的简洁性 提高线程池的稳定性和效率

在Java中，当子类覆盖（重写）父类的方法时，关于异常的规则如下：

1. 如果父类的方法没有抛出任何已检查的异常，那么子类的方法也不能抛出任何已检查的异常。子类的方法可以抛出任何未检查的异常。

2. 如果父类的方法抛出了一个或多个已检查的异常，那么子类的方法可以选择不抛出任何异常，也可以选择抛出父类方法抛出的一个或多个异常，或者抛出这些异常的任何子类。但是，子类的方法不能抛出新的已检查的异常，或者抛出更广泛的异常。

这些规则确保了子类的对象可以替换父类的对象，而不会破坏已有的异常处理代码。这是Java的多态性的一个重要部分。

以下是一些示例：

```java
// 父类
public class Parent {
    public void method1() { } // 不抛出任何已检查的异常

    public void method2() throws IOException { } // 抛出一个已检查的异常
}

// 子类
public class Child extends Parent {
    @Override
    public void method1() throws IOException { } // 错误！不能抛出新的已检查的异常

    @Override
    public void method2() { } // 正确。可以选择不抛出任何异常

    @Override
    public void method2() throws IOException { } // 正确。可以选择抛出父类方法抛出的异常

    @Override
    public void method2() throws FileNotFoundException { } // 正确。可以选择抛出父类方法抛出的异常的子类

    @Override
    public void method2() throws Exception { } // 错误！不能抛出更广泛的异常
}
```

![img_221.png](img_221.png)

线程包含了哪些状态？状态之间又是如何转移的？（说一下线程的生命周期）
![img_222.png](img_222.png)

![img_223.png](img_223.png)

![img_224.png](img_224.png)

如何让3个线程按顺序执行？
![img_225.png](img_225.png)

![img_226.png](img_226.png)

![img_227.png](img_227.png)

如何打断一个线程？
![img_228.png](img_228.png)

在Java中，`Thread`类的`stop`方法被标记为过时的，不推荐使用，主要有以下几个原因：

1. **数据不一致**：`stop`方法会立即停止线程的运行，这可能会导致对象处于不一致的状态。例如，如果一个线程正在执行一个复杂的更新操作，突然被`stop`方法停止，那么可能只有部分更新被完成，这会导致数据的不一致。

2. **释放资源**：`stop`方法会导致线程立即停止，这意味着它可能在完成清理工作之前就被停止。例如，如果一个线程打开了一个文件进行写操作，然后被`stop`方法停止，那么这个文件可能永远不会被正确关闭，这可能会导致数据丢失。

3. **异常处理**：`stop`方法会抛出`ThreadDeath`异常，如果你的代码没有准备好处理这个异常，那么这可能会导致意外的行为。

因此，更推荐的做法是使用中断机制来停止线程。你可以调用线程的`interrupt`方法来设置线程的中断状态，然后在线程的运行代码中检查这个状态，并在适当的时候停止线程的运行。这种方式更安全，更可控，也更符合Java的异常处理和资源管理的原则。

# 线程的并发安全
## sychronized关键字
![img_229.png](img_229.png)

![img_230.png](img_230.png)

![img_231.png](img_231.png)

![img_232.png](img_232.png)

![img_233.png](img_233.png)

![img_234.png](img_234.png)

![img_235.png](img_235.png)

![img_236.png](img_236.png)

![img_237.png](img_237.png)

![img_238.png](img_238.png)

## JMM
![img_239.png](img_239.png)

![img_240.png](img_240.png)

## CAS
![img_241.png](img_241.png)

乐观锁认为所有的线程都不存在竞争 所以他并不会进行加锁 悲观锁认为 所有线程都会将修改数据 所以每个线程过来都会进行加锁

![img_242.png](img_242.png)

就是说我其实是想在某个值的基础上进行修改，如果这个值没有被修改过，那么我就可以进行修改，如果被修改过，那么我就不进行修改

![img_244.png](img_244.png)

cas自旋的优势在于，它不会让线程进入阻塞状态，而是一直尝试修改数据，直到成功为止。这样可以减少线程的上下文切换，提高系统的性能。

但是，cas自旋在线程数大于CPU核心数时可能会导致性能下降，因为线程会一直占用CPU资源，导致其他线程无法执行。因此，cas自旋通常适用于线程数少于CPU核心数的情况。

![img_243.png](img_243.png)

![img_245.png](img_245.png)

![img_246.png](img_246.png)

## volatile关键字

作用是保证变量的可见性，即当一个线程修改了一个volatile变量的值，其他线程可以立即看到这个变化。这是因为volatile变量会被存储在主内存中，而不是线程的本地内存中，这样所有的线程都可以看到这个变量的最新值。

![img_247.png](img_247.png)

![img_248.png](img_248.png)

![img_249.png](img_249.png)

![img_250.png](img_250.png)

![img_251.png](img_251.png)

![img_252.png](img_252.png)

![img_253.png](img_253.png)

## AQS
![img_254.png](img_254.png)

![img_255.png](img_255.png)

![img_256.png](img_256.png)

![img_257.png](img_257.png)

## ReentrantLock

它是一个可重入的互斥锁，它的实现基于AQS（AbstractQueuedSynchronizer）框枧，它提供了与synchronized关键字类似的功能，但是更加灵活和强大。

它默认是非公平锁，但是可以通过构造函数来指定为公平锁。它提供了更多的功能，如可中断锁、超时锁、多条件变量等。
![img_258.png](img_258.png)

![img_259.png](img_259.png)

![img_260.png](img_260.png)

![img_261.png](img_261.png)

![img_262.png](img_262.png)

ReentrantLock支持的可打断是指获取锁的过程中是可以打断的，syncronized是不可以打断的
ReentrantLock支持的超时等待是指获取锁的过程中是可以等待一段指定时间，如果超时则不再等待，而syncronized是一直等待
ReentrantLock支持多条件变量，也就是多休息室，syncronized是不支持的

## 死锁产生的条件是什么？
![img_263.png](img_263.png)

![img_264.png](img_264.png)

![img_265.png](img_265.png)

![img_266.png](img_266.png)

![img_267.png](img_267.png)

## 检测死锁的工具
![img_269.png](img_269.png)

![img_268.png](img_268.png)

![img_271.png](img_271.png)

![img_270.png](img_270.png)

## ConcurrentHashMap
![img_274.png](img_274.png)

![img_272.png](img_272.png)

![img_273.png](img_273.png)

## 导致并发程序出现问题的根本原因是什么？
![img_275.png](img_275.png)![img_276.png](img_276.png)

![img_277.png](img_277.png)

![img_278.png](img_278.png)

解决可见性问题，可以采用volatile关键字、synchronized关键字、ReentrantLock等方式来保证变量的可见性。
但是，后两种方式会引入锁的开销，可能会影响程序的性能。因此，volatile关键字是更轻量级的解决方案，更适合用于保证变量的可见性。
![img_279.png](img_279.png)

![img_280.png](img_280.png)

![img_281.png](img_281.png)

# 线程池
## 线程池的核心参数
![img_282.png](img_282.png)

![img_283.png](img_283.png)

## 线程池中常见的阻塞队列
![img_284.png](img_284.png)

![img_285.png](img_285.png)

LinkedBlockingQueue是一个无界队列(可选有界)，一般使用时我们都会设置一个默认容量值，如果不设置，默认容量是Integer.MAX_VALUE，这样可能会导致内存溢出。

![img_286.png](img_286.png)

创建时如果不给参数，默认以Integer.MAX_VALUE为界限

ArrayBlockingQueue是一个强制有界队列

![img_287.png](img_287.png)

LinkedBlockingQueue的队头和队尾各有一个锁，而ArrayBlockingQueue只有一个锁，所以LinkedBlockingQueue的吞吐量会更高。

## 如何确定核心线程数
![img_288.png](img_288.png)

![img_289.png](img_289.png)

## 线程池的种类
![img_290.png](img_290.png)

![img_291.png](img_291.png)

![img_292.png](img_292.png)

![img_294.png](img_294.png)

![img_293.png](img_293.png)

其实这里的阻塞是指放入/取出线程的时候，如果队列满了，那么就会阻塞，如果队列为空，那么也会阻塞

这个阻塞队列就是生产者消费者模型

## 为什么不建议使用Executors创建线程池
![img_295.png](img_295.png)

## CountDownLatch
![img_296.png](img_296.png)

![img_297.png](img_297.png)

## 线程池的使用场景
![img_298.png](img_298.png)

在本项目中使用了线程池来来处理短链接访问记录的查询任务，不同线程查询不同的记录表，提高了查询效率。
![img_299.png](img_299.png)

![img_300.png](img_300.png)
可以用来记录日志
批量创建短链接的时候，可以使用线程池

![img_301.png](img_301.png)

## 信号量机制
![img_302.png](img_302.png)

考虑用信号量机制来控制并发访问量，防止系统被恶意攻击。

如何控制某个方法允许并发访问的线程的数量
![img_303.png](img_303.png)

## TheadLocal
![img_304.png](img_304.png)

![img_305.png](img_305.png)

是不是一个ThreadLocal对象作为key，只能存一个值，一个线程中通过多个ThreadLocal对象来存储多个值，然后不同线程的ThreadLocal又互不相干

![img_306.png](img_306.png)

![img_307.png](img_307.png)
每个线程都有自己的ThreadLocalMap，这个map中存储了所有的ThreadLocal对象和对应的值，所以每个线程中的ThreadLocal对象是互不相干的。

![img_308.png](img_308.png)

threadLocalMap的每个槽都是一个继承自WeakReference的Entry对象，这个Entry对象中存储了ThreadLocal对象和对应的值。

![img_309.png](img_309.png)

![img_310.png](img_310.png)


