# spring
## AOP和事务
![img_84.png](img_84.png)

![img_85.png](img_85.png)

![img_87.png](img_87.png)

![img_86.png](img_86.png)

![img_88.png](img_88.png)

AOP原理
把通用的代码信息抽取出来，不要与业务代码耦合
![img_89.png](img_89.png)

![img_90.png](img_90.png)

![img_91.png](img_91.png)

Spring事务失效的场景
1.异常捕获处理
![img_92.png](img_92.png)
这个可以理解，事务是发生异常，交给系统自动处理，自己手动捕获，系统认为 代码就没问题就不会回滚

2.抛出了受检异常，spring默认是不处理受检异常的，需要在@Transactional注解中加上rollbackFor属性，例如@Transactional(rollbackFor = Exception.class)
![img_93.png](img_93.png)
面试官：什么是检查异常？什么是非检查异常？都有哪些？
检查异常：编译器会检查的异常，必须要处理的异常，比如IOException
非检查异常：编译器不会检查的异常，运行时异常，比如NullPointerException
你还知道哪些非检查异常？

3.非public方法也会导致事务失效
![img_95.png](img_95.png)

4.事务方法内部调用事务方法，事务失效

项目中的AOP

## bean的生命周期
![img_94.png](img_94.png)

![img_96.png](img_96.png)

![img_97.png](img_97.png)

## spring中的循环引用问题
![img_98.png](img_98.png)

![img_99.png](img_99.png)

![img_100.png](img_100.png)

![img_101.png](img_101.png)
一级缓存和二级缓存可以解决一般对象的循环引用问题，
但是对于代理对象的循环引用问题，需要使用ObjectFactory来解决
![img_102.png](img_102.png)
就是通过注入一个没有初始化完全的对象的引用，来走完一个对象的创建流程。然后当另一个对象创建完成之后，之前赋值的引用指向的对象也就从没有初始化完全的对象变成初始化完全的对象了
![img_103.png](img_103.png)

![img_104.png](img_104.png)

# springMVC
## springMVC的执行流程
JSP视图阶段
![img_105.png](img_105.png)

![img_107.png](img_107.png)

处理器执行链中包含待执行的handler和拦截器链（如果有拦截器的话）

大前端时代
![img_106.png](img_106.png)

![img_108.png](img_108.png)

# springboot
## springboot自动装配原理
![img_109.png](img_109.png)

![img_110.png](img_110.png)

![img_111.png](img_111.png)

![img_112.png](img_112.png)

## springboot常见注解
![img_113.png](img_113.png)

spring常见注解：
![img_114.png](img_114.png)

springmvc常见注解：
![img_115.png](img_115.png)

springboot常见注解：
![img_116.png](img_116.png)

高频面试题：
1. Spring和Spring Boot的区别：
    - Spring是一个开源的Java平台，它提供了一种简单的方法来开发Java应用程序。它通过提供一种简单的方法来管理对象的创建和生命周期，以及通过依赖注入和面向切面编程来提供服务。
    - Spring Boot是基于Spring的一个框架，其设计目标是简化新Spring应用的初始搭建以及开发过程。Spring Boot通过提供默认配置来简化项目配置，使得开发人员能更专注于业务开发。此外，Spring Boot还内置了一个运行时的应用服务器，使得开发和测试变得更加方便。

2. Spring的DI（依赖注入）和IOC（控制反转）：
    - 控制反转（IOC）是一种设计原则，用于降低计算机程序各组件间的耦合度。在Spring框架中，IOC容器负责管理对象的生命周期和依赖关系。
    - 依赖注入（DI）是实现IOC的一种方法，它允许将依赖关系从代码中移除，通过外部方式提供依赖。这样可以使得代码更加灵活，更易于测试和维护。

3. JDK动态代理和CGLIB动态代理的区别：
    - JDK动态代理是Java原生支持的代理方式，它要求目标对象必须实现一个或多个接口。在运行时，JVM会创建目标对象的代理对象，代理对象会实现与目标对象相同的接口，因此可以被当作目标对象使用。
    - CGLIB动态代理是一个强大的高性能的代码生成库，它可以在运行时扩展Java类与实现Java接口。它广泛的被许多AOP框架使用，如Spring AOP和dynaop，为他们提供方法的拦截。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不同于JDK动态代理，CGLIB动态代理不要求目标对象实现任何接口，它是通过在运行时生成目标对象的子类来实现代理的。

4. 拦截器和过滤器的区别：
    - 过滤器（Filter）是Java Servlet规范中的一部分，可以在请求到达Servlet之前，或响应返回客户端之前，对请求/响应进行预处理/后处理。过滤器链是由服务器管理的。
    - 拦截器（Interceptor）是被用来在AOP（面向切面编程）中实现某些横切关注点的编程模式。在Spring MVC中，拦截器可以在请求被实际处理之前，或视图被渲染之前，提供自定义的请求和响应处理。拦截器链是由Spring MVC提供的。

# mybatis
配置文件的编写，内容包含我要连接哪个数据库及我要使用哪些mapper文件
![img_117.png](img_117.png)

执行流程：
![img_118.png](img_118.png)

![img_119.png](img_119.png)
mappedStatement就是一个sql语句的封装，包含了sql语句的id，参数类型，返回值类型，sql语句等信息

完整执行流程：
![img_120.png](img_120.png)

![img_121.png](img_121.png)

mybatis的延迟加载
![img_122.png](img_122.png)

![img_123.png](img_123.png)

![img_124.png](img_124.png)

mybatis的一级缓存和二级缓存
![img_125.png](img_125.png)

案例：
![img_126.png](img_126.png)
这里的mapper1和mapper2都使用了同一个sqlSession，所以在mapper1中查询了一次，mapper2就不会再查询了，直接从缓存中拿
![img_127.png](img_127.png)

二级缓存
![img_128.png](img_128.png)

![img_129.png](img_129.png)

![img_130.png](img_130.png)

# 微服务
## 服务注册
![img_131.png](img_131.png)

![img_132.png](img_132.png)

![img_133.png](img_133.png)

![img_134.png](img_134.png)

## Ribbon负载均衡：
![img_135.png](img_135.png)

![img_136.png](img_136.png)

标红的是需要重点掌握的
![img_137.png](img_137.png)
最后一个是区域敏感性策略
![img_138.png](img_138.png)

![img_139.png](img_139.png)

## 服务雪崩
服务降级
![img_140.png](img_140.png)
服务熔断
![img_141.png](img_141.png)

![img_142.png](img_142.png)

## 服务监控
![img_143.png](img_143.png)

![img_144.png](img_144.png)

![img_145.png](img_145.png)

## 限流
![img_146.png](img_146.png)

nginx里面控制速率用到的就是漏桶算法
![img_147.png](img_147.png)
这里的rate是指针对一个相同的ip每秒最多处理10个请求，而不是每秒只能处理10个请求

![img_148.png](img_148.png)

令牌桶与漏桶的区别：
- 令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中是否有足够的令牌，当桶中没有令牌时，请求被拒绝。
- 漏桶是按照固定速率从桶中移除水滴，当水滴超过桶的容量时，多余的水滴被溢出，请求被拒绝。
- 令牌桶允许一定程度的突发流量，只要桶中有足够的令牌，就可以处理请求；漏桶对突发流量是强制的，流量超过桶的容量时，请求被拒绝。
![img_149.png](img_149.png)

![img_150.png](img_150.png)

![img_151.png](img_151.png)

限流常见的算法有哪些？
令牌桶和漏桶

短链接后台的流量控制策略是什么？怎么实现的？中台的流量控制策略是什么？怎么实现的？

先说一下短链接后台的流控策略，后台的流控策略是设置是在UserFlowRiskControlFilter类中实现的
针对平台用户，我们使用用户名来做限流，针对未登录用户（比如访问登录接口的用户），我们统一使用other来做限流
![img_159.png](img_159.png)

具体的流控策略是根据我们配置文件中写的规则来进行限流，比如我们可以配置每秒钟最多访问20次，以及控制是否开启流控策略
![img_160.png](img_160.png)

中台系统因为要接收海量访问，所以我们使用了Sentinel来做限流，设置qps为20
![img_161.png](img_161.png)

## 分布式理论
CAP理论
![img_152.png](img_152.png)

![img_153.png](img_153.png)

![img_154.png](img_154.png)

![img_155.png](img_155.png)

BASE理论
![img_156.png](img_156.png)

![img_157.png](img_157.png)